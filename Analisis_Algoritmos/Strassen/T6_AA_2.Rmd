---
author: Gabriela Vargas, Dalia Camacho, Elizabeth Monroy
title: Algoritmo Strassen para multiplicación de matrices
output: pdf_document
---

El método usual para multiplicar matrices es de orden $O(n^3)$, sin embargo en 1969 Volker Strassen propuso un método más eficiente para la multiplicación de matrices cuadradas de tamaño $n \times n$, donde $n$ es par. Este método consiste en dividir las dos matrices en cuatro submatrices de tamaño $\frac{n}{2}$; realizar operaciones aditivas de estas matrices; llevar a cabo 7 multiplicaciones de matrices y finalmente unir los resultados. De esta forma la multiplicación de matrices se convierte en un problema de orden $O(n^{log7})=O(n^{2.81})$ superando asintóticamente al método clásico de orden $O(n^{log8})=O(n^{3})$.

Como ejemplo particular para matrices de $2\times 2$ con el método de Strassen se requieren 7 multiplicaciones escalares, en vez de las 8 necesarias en el método clásico. 

El algoritmo de Strassen hace uso del método *Divide y vencerás*, esto implica resolver un problema difícil dividiéndolo en partes tantas veces como sea necesario hasta que la solución de las partes sea simple. 


Otros métodos se han desarrollado para disminuir el orden del algoritmo de multiplicación de matrices. El algoritmo más eficiente hasta ahora es el de Virginia Vassilevska Williams, quien en 2014 logró bajar el orden a $O(n^{2.373})$. Este algoritmo utiliza formas trilineales, en vez de bilineales para representar la multiplicación de matrices.

```{r, echo=FALSE}
library(ggplot2)
x  <- 1:50
y1 <- x^3
y2 <- x^(log2(7))
y3 <- (x^2.373)

ggplot()+theme_bw()+
  geom_line(aes(x, y1, color="n^3"))+
  geom_line(aes(x, y2, color="n^log_2(7)"))+
  geom_line(aes(x, y3, color="n^2.373"))+
  xlab("n")+
  ylab("Tiempo")+
  theme(legend.title = element_blank())+
  theme(legend.position = "bottom")
  

```

Dadas dos matrices cuadradas $A$ y $B$, de tamaño $n\times n$, el producto de matrices $C$ se define como $$\left(\begin{array}{cc}C_{11} & C_{12} \\C_{11} & C_{12}\end{array}\right)=\left(\begin{array}{cc} A_{11} & A_{12} \\A_{11} & A_{12}                          \end{array}\right)\cdot\left(\begin{array}{cc} B_{11} & B_{12} \\B_{11} & B_{12}                                                             \end{array}\right)$$

Aplicando el método tradicional de multiplicación de matrices, tenemos que:
\begin{equation}
\begin{aligned}
C_{11}&= A_{11}\cdot B_{11}+A_{12}\cdot B_{12},\\
C_{12}&= A_{11}\cdot B_{12}+A_{12}\cdot B_{22}, \\ 
C_{21}&= A_{21}\cdot B_{11}+A_{22}\cdot B_{21}, \\ 
C_{22}&= A_{21}\cdot B_{12}+A_{22}\cdot B_{22}
\end{aligned}
\end{equation}
En cada una de las cuatro ecuaciones se especifican dos multiplicaciones de matrices de tamaño $n/2\times n/2$ y la suma de estos productos. 

La idea del algoritmo Strassen es particionar las matrices $A$ y $B$ tal que en lugar de ocupar 8 multiplicaciones para obtener la matriz $A\cdot B=C$, únicamente se ocupen 7. Este algoritmo consta de cuatro pasos:

1. Dividir las matrices $A$, $B$ y $C$ en submatrices de tamaño $n/2\times n/2$ .
2. Crear 10 matrices $S_{1},S_{2},\dots ,S_{10}$, de $n/2\times n/2$ cada una, las cuales son resultado de la suma o resta de las  matrices creadas en el paso uno.
3. Calcular 7 productos de matrices $P_{1},P_{2},\dots ,P_{7}$ mediante las submatrices creadas en el paso uno y las submatrices $S$ creadas en el paso dos.
4. Calcular las submatrices $C_{11},C_{12},C_{21},C_{22}$ a través de la suma y resta de diferentes combinaciones de las matrices $P_{i}$.

Las diez matrices del paso dos están definidas como:

\begin{equation}
\begin{aligned}
S_1  &= B_{12} - B_{22}\\
S_2  &= A_{11} + A_{12}\\
S_3  &= A_{21} + A_{22}\\
S_4  &= B_{21} - B_{11}\\
S_5  &= A_{11} + A_{22}\\
S_6  &= B_{11} + B_{22}\\
S_7  &= A_{12} - A_{22}\\
S_8  &= B_{21} + B_{22}\\
S_9  &= A_{11} - A_{21}\\
S_{10} &= B_{11} + B_{12}.\\
\end{aligned}
\end{equation}

Las multiplicaciones de matrices del paso tres están dadas por:

\begin{equation}
\begin{aligned}
P_1 &= A_{11} \cdot S_1\\
P_2 &= S_2 \cdot B_{22}\\
P_3 &= S_3 \cdot B_{11}\\
P_4 &= A_{22} \cdot S_4\\
P_5 &= S_5 \cdot S_6\\
P_6 &= S_7 \cdot S_8\\
P_7 &= S_9 \cdot S_{10}.\\
\end{aligned}
\end{equation}

Para obtener la matriz $C=A\cdot B$ calculamos las submatrices $C_{11},C_{12},C_{21},C_{22}$:

\begin{equation}
\begin{aligned}
C_{11} &= P_5 + P_4 - P_2 + P_6\\
C_{12} &= P_1 + P_2\\
C_{21} &= P_3 + P_4\\
C_{22} &= P_5 + P_1 - P_3 - P_7.\\
\end{aligned}
\end{equation}


##Implementación

Se define una función para ejecutar el algoritmo.
```{r}
# La función divide recibe como input una matriz cuadrada
# A de tamaño nxn.
# El output de la función es una lista con las cuatro
# submatrices de tamaño n/2xn/2.

divide <- function(A){
  r   <- dim(A)[1]
  A   <- list(A)
  A11 <- A[[1]][1:(r/2),1:(r/2)]
  A12 <- A[[1]][1:(r/2),(r/2+1):r]
  A21 <- A[[1]][(r/2+1):r,1:(r/2)]
  A22 <- A[[1]][(r/2+1):r,(r/2+1):r]
  A   <- list(X11=A11, X12=A12,X21=A21,X22=A22)
  return(A)
}

```

```{r}
# El código de Strassen con cada paso en el algoritmo 
# por separado
strassen_largo <- function(A,B){
  # Dividir las matrices A y B en matrices de n/2xn/2
  A  <- divide(A)
  B  <- divide(B)
  
  # Generar las diez matrices del algoritmo de Strassen
  S1  <- B$X12 - B$X22
  S2  <- A$X11 + A$X12
  S3  <- A$X21 + A$X22
  S4  <- B$X21 - B$X11
  S5  <- A$X11 + A$X22
  S6  <- B$X11 + B$X22
  S7  <- A$X12 - A$X22
  S8  <- B$X21 + B$X22
  S9  <- A$X11 - A$X21
  S10 <- B$X11 + B$X12
  
  # Se calculan los productos que dan lugar a las
  # 7 matrices P
  
  P1 <- A$X11 %*% S1
  P2 <- S2 %*% B$X22
  P3 <- S3 %*% B$X11
  P4 <- A$X22 %*% S4
  P5 <- S5 %*% S6
  P6 <- S7 %*% S8
  P7 <- S9 %*% S10
  
  # Se suman y restan las matrices P para obtener la 
  # multiplicación de A y B por subcuadrante
  
  C11 <- P5 + P4 - P2 + P6
  C12 <- P1 + P2
  C21 <- P3 + P4
  C22 <- P5 + P1 - P3 - P7
  
  # Juntar los subcuadrantes en la matriz C
  C <- rbind(cbind(C11,C12),cbind(C21,C22))
  
  return(C)
  
}
```

```{r}
# El código de Strassen uniendo los pasos 2 y 3 en uno solo


strassen <- function(A,B){
  # Dividir las matrices A y B
  A  <- divide(A)
  B  <- divide(B)
  
  # Juntar los pasos 2 y 3
  
  M1 <- (A$X11+A$X22)%*%(B$X11+B$X22)
  M2 <- (A$X21+A$X22)%*%B$X11
  M3 <- A$X11%*%(B$X12-B$X22)
  M4 <- (A$X22)%*%(B$X21-B$X11)
  M5 <- (A$X11+A$X12)%*%B$X22
  M6 <- (A$X21-A$X11)%*%(B$X11+B$X12)
  M7 <- (A$X12-A$X22)%*%(B$X21+B$X22)
  
  # Formar la matriz C con las Ms calculadas previamente
  C11<-M1+M4-M5+M7
  C12<-M3+M5
  C21<-M2+M4
  C22<-M1-M2+M3+M6
  
  # Juntar los subcuadrantes en la matriz C
  C<-rbind(cbind(C11,C12),cbind(C21,C22))
  
  
  return(C)
  
}

```

Se prueba el algoritmo para calcular la multiplicación de las matrices $A$ y $B$ por medio del algortimo Strassen.
Se compara el resultado con la matriz $C$ que representa el resultado de la operación de producto matricial en R.


```{r}
set.seed(53564)
# Crear matrices para la prueba
A <- matrix(round(runif(64,0,1)*10),8)
A

B <- matrix(round(runif(64,0,1)*10),8)
print("Matriz B")
print(B)

```

Resultado de multiplicación de matrices usando el operador de R
```{r}
C <- A%*%B
C
```

Resultado de multiplicación de matrices usando la función Strassen con los pasos dos y tres por separado:

```{r}
C_strassenL <- strassen_largo(A,B)
```

```{r}
C_strassenL
```

Comparación del método de R con Strassen con los pasos dos y tres por separado.
```{r}
C_strassenL == C
```

Resultado de multiplicación de matrices, usando la función Strassen con los pasos dos y tres juntos:

```{r}
C_strassenS <- strassen(A,B)
```

```{r}
C_strassenS
```

Comparación del método de R con Strassen con los pasos dos y tres juntos.
```{r}
C_strassenS == C
```




